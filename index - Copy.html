<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS-Breakout</title>

    <!--    use CSS from bootstrap-->
    <link href="css/bootstrap/bootstrap.css" rel="stylesheet">
    <link href="css/bootstrap/bootstrap-grid.css" rel="stylesheet">
    <link href="css/bootstrap/bootstrap-reboot.css" rel="stylesheet">
    <link href="css/bootstrap/bootstrap-utilities.css" rel="stylesheet">

    <!--    use CSS from my own files-->
    <link href="css/gameScreen.css" rel="stylesheet">
    <link href="css/mainMenu.css" rel="stylesheet">
    <link href="css/global.css" rel="stylesheet">
</head>

<!--import audio into the html-->
<audio id="gameOverSound" src="sounds/gameOver.mp3"></audio>
<audio id="brickHitSound" src="sounds/breakBrick.mp3"></audio>
<audio id="bounceSound" src="sounds/wallBounce.mp3"></audio>
<audio id="victory" src="sounds/victory.mp3"></audio>
<audio id="music" src="sounds/music.mp3" loop></audio>
<audio id="powerUpSound" src="sounds/powerup.mp3"></audio>
<audio id="levelWonSound" src="sounds/LevelWon.mp3"></audio>


<header>
    <h1>JS Breakout</h1>
</header>


<p class="rotate-message">Please rotate your device to landscape mode to play.</p>


<main>
    <!-- game screen-->
    <div id="gameScreen">
        <div class="canvas-container">
            <canvas id="breakoutCanvas" width="720" height="240"></canvas>
        </div>
    </div>


    <!--    main menu-->
    <section id="mainMenu">
        <button id="startGameButton" class="play-button">New Game</button>
        <button id="loadGameButton" class="play-button" disabled>Load Last Saved Game</button>

        <!--        settings section-->
        <div id="settingsScreen">

            <!--            give the player the option of setting a speed for the ball-->
            <h2 id="settingsHeader">Game Settings</h2>


            <h3>Ball Speed</h3>

            <div class="settingsDiv">
                <button id="slowButton" class="speedButton">Slow</button>
                <button id="mediumButton" class="speedButton active">Medium</button>
                <button id="fastButton" class="speedButton">Fast</button>
            </div>

            <h3>Paddle speed</h3>

            <div class="settingsDiv">
                <label for="paddleSpeedInput">Paddle Speed (1-10)</label>
                <input type="number" name="paddleSpeedInput" id="paddleSpeedInput" autofocus placeholder="5" min="1"
                       max="10">
            </div>

            <h3>Sound</h3>
            <div class="settingsDiv">
                <label for="muteCB">Mute music?</label>
                <input type="checkbox" name="mute" id="muteCB" checked>
            </div>

        </div>

    </section>

    <!--    modal window for telling player the game is over-->
    <section id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverHeader">Game Over</h2>
            <p id="gameOverMessage">You reached level: <span id="finalScore">0</span></p>
            <button id="restartButton">Restart</button>
            <button id="menuButton">Main Menu</button>
        </div>
    </section>

    <!--    modal window for telling player the level is complete-->
    <div id="nextLevelModal" class="modal-content">
        <h5>Level Complete!</h5>
        <p id="nextLevelText"></p>
        <button id="nextLevelButton">Continue and Save</button>
    </div>
</main>
<footer>
    <!--    my contact info-->
    <p>Made by Adam Å trobl. Contact me at <a href="mailto:strobad1@fel.cvut.cz">strobad1@fel.cvut.cz</a></p>
</footer>

<script>


    //region querySelectors
    const loadGameButton = document.getElementById('loadGameButton');

    const gameOverHeader = document.getElementById('gameOverHeader');
    const gameOverMessage = document.getElementById('gameOverMessage');
    const paddleSpeedInput = document.getElementById('paddleSpeedInput');
    const muteCB = document.getElementById('muteCB');
    const nextLevelModal = document.querySelector("#nextLevelModal");
    const nextLevelButton = document.querySelector("#nextLevelButton");
    const nextLevelText = document.querySelector("#nextLevelText");
    const speedButtons = document.querySelectorAll('.speedButton');
    speedButtons.forEach(button => {
        button.addEventListener('click', () => {
            // Remove 'active' class from all speed buttons
            speedButtons.forEach(btn => btn.classList.remove('active'));

            // Add 'active' class to the clicked button
            button.classList.add('active');

            // Handle the click event for the selected game speed
            handleGameSpeed(button.id);
        });
    });
    const restartButton = document.querySelector("#restartButton");
    const menuButton = document.querySelector("#menuButton");
    const gameOverModal = document.querySelector("#gameOverModal");
    const finalScoreSpan = document.querySelector("#finalScore");
    const modalContent = document.querySelector(".modal-content");

    const mainMenu = document.getElementById('mainMenu');
    const gameScreen = document.getElementById('gameScreen');
    const settingsScreen = document.getElementById('settingsScreen');
    const startGameButton = document.getElementById('startGameButton');

    //endregion


    //region sounds
    const music = document.getElementById('music');
    const gameOverSound = document.getElementById('gameOverSound');
    const brickHitSound = document.getElementById('brickHitSound');
    const bounceSound = document.getElementById('bounceSound');
    const victorySound = document.getElementById('victory');
    const powerUpSound = document.getElementById('powerUpSound');
    const levelWonSound = document.getElementById('levelWonSound');

    let isMuted = true;

    muteCB.addEventListener('click', () => {
        isMuted = !isMuted; // Toggle mute state
        if (isMuted) {
            music.pause();
        }
    });

    function playSound(sound) {
        if (!isMuted) {
            // Check if the sound is music and if musicAudio is not already playing
            if (sound === music) {
                music.play();
            } else {
                const audio = new Audio(sound.src);
                audio.currentTime = 0;
                audio.play();
            }
        }
    }


    //endregion


    // region declarations
    let frameCount = 0;

    let gamePaused = false;
    let paddleSpeed = 5;
    let gameWon = false;
    const POWER_UP_DURATION = 15 * 1000;
    const gameSpeedOptions = {
        SLOW: 0.2,
        MEDIUM: 0.5,
        FAST: 1
    }
    let selectedSpeed = gameSpeedOptions.MEDIUM;


    const canvas = document.getElementById("breakoutCanvas");
    const canvasContainer = canvas.parentElement;

    const ctx = canvas.getContext("2d");

    let currCanvasWidth = canvas.width;
    let currCanvasHeight = canvas.height;

    const PADDLE_HEIGHT_PERCENT = 0.030;
    const PADDLE_WIDTH_DEFAULT_PERCENT = 0.15;
    const PADDLE_WIDTH_LARGE_PERCENT = 0.35;

    const BALL_RADIUS_PERCENT = 0.02;
    const WEAK_BRICK_COLOR = "#8f9815";
    const STRONG_BRICK_COLOR = "#af3221";

    const REGULAR_BALL_COLOR = "#89c91e";
    const STRONG_BALL_COLOR = "#087cee";
    let currentBallColor = REGULAR_BALL_COLOR;

    let moveByAmount = 5 * 1.3;


    let mouseX = 0;
    let rightPressed = false;
    let leftPressed = false;

    let ballPow = 1;
    let gameSpeed = 1;

    const maxGameSpeed = 2.5 * gameSpeed;
    const framesToReachMaxSpeed = 30 * 60;


    let moveSpeedMultiplier = 0.01;

    let paddle;
    let ball;
    let powerUps;

    let powerUpWidthPercent = 0.015;
    let powerUpSpeedPercent = 0.005;

    const bricks = [];
    let currentLevel = 0;


    let num_brick_rows = 5;
    let num_brick_cols = 17;


    let borderPaddingLRPercent = 0.10;
    let borderPaddingBottomPercent = 0.50;
    let borderPaddingTopPercent = 0.10;


    const levelLayouts = [
        // 0 = no brick, 1 = weak brick, 2 = strong brick


        // // Level 1 for cheaters
        //
        // [
        //     [1],
        // ],
        // // Level 2 for cheaters
        // [
        //     [0,1],
        // ],

        // level 1
        [

            [1, 1, 1, 1, 1, 0, 0, 2, 0, 2, 0, 0, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 0, 0, 2, 0, 2, 0, 0, 1, 1, 1, 1, 1],
        ],
        // Level 2
        [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],
            [1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],
            [1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ],


    ]

    //endregion

    //region Classes
    /**
     * Class representing the paddle
     * @class
     * @classdesc Represents a paddle in the game
     */
    class Paddle {
        constructor() {
            this.width = currCanvasWidth * PADDLE_WIDTH_DEFAULT_PERCENT;
            this.height = currCanvasHeight * PADDLE_HEIGHT_PERCENT;
            // Set the paddle dimensions and initial position
            this.x = currCanvasWidth / 2 - this.width / 2;
        }

        // by default, paddle is controlled by keyboard
        controllingMedium = {
            KeyboardControlled: true,
            TouchControlled: false,
            MouseControlled: false
        }

        // Move the paddle to the right
        moveRight(amount = moveByAmount) {
            if (this.x + amount < currCanvasWidth - this.width) {
                this.x += amount;
            } else {
                this.x = currCanvasWidth - this.width;
            }
        }

        // Move the paddle to the left
        moveLeft(amount = moveByAmount) {
            if (this.x - amount > 0) {
                this.x -= amount;
            } else {
                this.x = 0;
            }
        }

        // Draw the paddle
        draw() {

            ctx.beginPath();
            ctx.rect(this.x, currCanvasHeight - this.height, this.width, this.height);
            ctx.fillStyle = REGULAR_BALL_COLOR;
            ctx.fill();
            ctx.closePath();

        }

    }


    /**
     * Class representing the ball
     * @class
     * @classdesc Represents a ball in the game
     */
    class Ball {
        // Set the ball dimensions and initial position and speed
        constructor() {
            this.radius = currCanvasHeight * BALL_RADIUS_PERCENT;

            this.x = currCanvasWidth / 2;
            this.y = currCanvasHeight - paddle.height - this.radius - 1;

            //random horizontal direction
            this.dx = (Math.random() < 0.5 ? -1 : 1) * 7 * gameSpeed;
            this.dy = 4 * gameSpeed;
        }

        // Draw the ball
        draw() {


            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = currentBallColor;
            ctx.fill();
            ctx.closePath();
        }

        move() {
            this.x += this.dx;

            this.y += this.dy;

// if ball got moved off screen by the ceiling or walls, teleport it back to the nearest wall

            if (this.x + this.dx > currCanvasWidth - this.radius) {

                this.x = currCanvasWidth - this.radius;

                playSound(bounceSound);

            } else if (this.x + this.dx < this.radius) {

                this.x = 0 + this.radius;

                playSound(bounceSound);

            } else if (this.y + this.dy < this.radius) {

                this.y = 0 + this.radius;

                playSound(bounceSound);

            }

// Bounce off walls

            if (this.x + this.dx > currCanvasWidth - this.radius || this.x + this.dx < this.radius) {

                this.dx = -this.dx;

                playSound(bounceSound);

            }

// Bounce off ceiling

            if (this.y + this.dy < this.radius) {

                this.dy = -this.dy;

                playSound(bounceSound);

            }

// Bounce off paddle

            else if (this.y + this.dy + paddle.height > currCanvasHeight - this.radius) {

                if (this.x > paddle.x && this.x < paddle.x + paddle.width) {

                    this.dy = -this.dy;

                    playSound(bounceSound);

// TODO still gets stuck

// Fix for ball getting stuck inside the paddle

                    if (this.y > currCanvasHeight - paddle.height) {

// Move the ball outside the paddle

                        this.y = currCanvasHeight - paddle.height - this.radius;

                    }

                }

            }

        }

        // Update the ball size based on the current canvas size
        updateSize() {
            this.radius = currCanvasHeight / BALL_RADIUS_PERCENT;
        }
    }

    /**
     * Class representing a power-up
     * @class
     * @classdesc Represents a power-up in the game
     * @abstract
     * @property {number} x - The x-coordinate of the power-up
     * @property {number} y - The y-coordinate of the power-up
     */
    class PowerUp {


        // Set the power-up dimensions and initial position
        constructor(x, y) {
            this.width =0;
            this.x = x;
            this.y = y
        }

        // Draw the power-up
        draw() {
            this.width = currCanvasWidth * powerUpWidthPercent;

            ctx.beginPath();
            ctx.rect(this.x, this.y, this.width, this.width);
            ctx.fillStyle = "red";
            ctx.fill();
            ctx.closePath();
        }

        // Move the power-up
        move() {
            this.y += gameSpeed * currCanvasHeight * powerUpSpeedPercent;
        }

        // Check for collisions with the paddle and act on it, implemented in subclasses
        ifPaddleHitGivePowerUp() {
        }


        // Check for collisions with the paddle
        checkCollisionWithPaddle() {
            if (this.x > paddle.x &&
                this.x < paddle.x + paddle.width &&
                this.y +this.width/2 > currCanvasHeight - paddle.height)
            {
                const index = powerUps.indexOf(this);
                powerUps.splice(index, 1);
                playSound(powerUpSound)
                return true;
            }
        }

        // Check if the power-up is out of bounds
        checkOutOfBounds() {
            // if out of screen
            if (this.y > currCanvasHeight) {
                const index = powerUps.indexOf(this);
                powerUps.splice(index, 1);
            }
        }

        // Update the power-up size based on the current canvas size
        updateSize() {
            this.x = currCanvasWidth *= this.x / 720;
            this.y = currCanvasHeight *= this.y / 240;
            this.width = currCanvasWidth / 72 / 2;
        }
    }

    /**
     * Class representing a wide paddle power-up
     * @class
     * @classdesc Represents a wide paddle power-up in the game
     * @extends PowerUp
     * @property {number} x - The x-coordinate of the power-up
     * @property {number} y - The y-coordinate of the power-up
     */
    class WidePowerUp extends PowerUp {
        constructor(x, y) {
            super(x, y);
        }

        // If the paddle hits the power-up, give it a power-up
        ifPaddleHitGivePowerUp() {
            if (this.checkCollisionWithPaddle()) {
                paddle.width = currCanvasWidth * PADDLE_WIDTH_LARGE_PERCENT;
                setTimeout(() => paddle.width = currCanvasWidth * PADDLE_WIDTH_DEFAULT_PERCENT, POWER_UP_DURATION);
            } else {
                super.checkOutOfBounds();
            }
        }


        updateSize() {
            super.updateSize();
        }
    }


    /**
     * Class representing a strong ball power-up
     * @class
     * @classdesc Represents a strong ball power-up in the game
     * @extends PowerUp
     * @property {number} x - The x-coordinate of the power-up
     * @property {number} y - The y-coordinate of the power-up
     */
    class StrongBallPowerUp extends PowerUp {
        constructor(x, y) {
            super(x, y);
        }

        // decides how strong the ball is and if it can break strong bricks instantly
        ballPow = 1;


        // If the paddle hits the power-up, give it a power-up
        ifPaddleHitGivePowerUp() {
            if (this.checkCollisionWithPaddle()) {
                ballPow = 3;
                currentBallColor = STRONG_BALL_COLOR;
                // Reset the ball power-up after a certain duration
                setTimeout(() => {
                    currentBallColor = REGULAR_BALL_COLOR;
                    ballPow = 1;
                }, POWER_UP_DURATION);
            } else {
                super.checkOutOfBounds();
            }
        }
    }

    /**
     * Class representing a brick
     * @class
     * @classdesc Represents a brick in the game
     * @property {number} x - The x-coordinate of the brick
     * @property {number} y - The y-coordinate of the brick
     * @property {number} status - The status of the brick (0 = destroyed, 1 = weak, 2 = strong)
     */

        //draw a new point at the top left corner of the canvas

    class Brick {
        x = 0;
        y = 0;
        width = 0;
        height = 0;

        constructor(column, row, status = 1) {
            this.column = column;
            this.row = row;
            this.status = status;
        }

        draw() {
            let color;
            // Draw the brick based on its status
            switch (this.status) {
                case 0:
                    return;
                case 1:
                    color = WEAK_BRICK_COLOR;
                    break;
                case 2:
                    color = STRONG_BRICK_COLOR;
                    break;

            }


            let brickPaddingPercent = 0.0045;

            // Calculate the total padding space for rows and columns
            let totalRowPadding = (num_brick_rows - 1) * brickPaddingPercent * currCanvasHeight;
            let totalColPadding = (num_brick_cols - 1) * brickPaddingPercent * currCanvasWidth;

            // Calculate the room available for bricks after subtracting padding
            let rowRoom = currCanvasHeight - (borderPaddingBottomPercent * currCanvasHeight) - totalRowPadding;
            let colRoom = currCanvasWidth - (borderPaddingLRPercent * currCanvasWidth) - totalColPadding;

            // Calculate the width and height of each brick
            this.width = colRoom / num_brick_cols;
            this.height = rowRoom / num_brick_rows;

            // Calculate the x and y position of each brick, adding padding
            this.x = this.column * (this.width + brickPaddingPercent * currCanvasWidth) + (borderPaddingLRPercent / 2 * currCanvasWidth);
            this.y = this.row * (this.height + brickPaddingPercent * currCanvasHeight) + (borderPaddingTopPercent * currCanvasHeight);

            ctx.beginPath();
            ctx.rect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();
        }


    }


    //endregion

    //region levels

    /**
     * Function to load the details of the specified level
     * @param {number} levelNum - The number of the level to load
     */
    function loadLevelDetails(levelNum) {
        // Clear existing bricks
        bricks.length = 0;
        // Set the game speed and number of brick rows and columns
        gameSpeed = selectedSpeed;
        num_brick_rows = levelLayouts[levelNum].length;
        num_brick_cols = levelLayouts[levelNum][0].length;

        // Clear existing power-ups
        powerUps = [];

        // Load the brick layout for the specified level
        const brickLayout = levelLayouts[levelNum];

        // Loop through the brick layout to create bricks
        for (let r = 0; r < num_brick_rows; r++) {
            bricks[r] = []; // Initialize each row as an empty array
            for (let c = 0; c < num_brick_cols; c++) {
                const brick = new Brick(c, r, brickLayout[r][c]); // Create a new brick
                bricks[r].push(brick); // Add the brick to the current row of bricks
            }
        }
    }


    /**
     * Function to set up the specified level by loading its details and initializing the game objects
     */
    function setUpLevel() {
        saveGameState();
        resizeCanvas()
        loadLevelDetails(currentLevel);

        paddle = new Paddle();
        ball = new Ball();
        gameLoop();
    }

    /**
     * Function to move to the next level
     */
    function nextLevel() {
        gamePaused = false;
        currentLevel++;

        if (currentLevel < levelLayouts.length) {
            setUpLevel();
        }


    }

    //endregion

    //region gameLogic
    /**
     * Function to start a new game
     */
    function newGame() {
        //reset all variables
        currentLevel = 0;
        gameWon = false;
        gamePaused = false;
        gameSpeed = selectedSpeed;
        playSound(music);

        // Set up the first level
        setUpLevel()
        initializeEventListeners();
    }


    /**
     * start game when the start button is clicked
     */
    startGameButton.addEventListener('click', () => {
        goToGameScreen();
        newGame();
    });

    /**
     * creates a new power up at the specified coordinates
     * @param x - x-coordinate of the power-up
     * @param y - y-coordinate of the power-up
     */
    function createPowerUp(x, y) {
        if (Math.random() < 0.5) {
            const powerUp = Math.random() < 0.5 ? new WidePowerUp(x, y) : new StrongBallPowerUp(x, y);
            powerUps.push(powerUp);
        }
    }


    /**
     * brick destruction logic, called each frame
     */
    function brickDestruction() {


        /**
         * Function to handle the ball hitting a brick
         * @param {Object} brick - The brick that the ball hits
         */
        function ballHitsBrick(brick) {
            switch (brick.status) {
                case 1:
                    brick.status = 0;
                    createPowerUp(brick.x, brick.y);
                    break;
                case 2:
                    if (ballPow >= 2) {
                        brick.status = 0;
                        createPowerUp(brick.x, brick.y);
                    } else {
                        brick.status = 1;
                    }
                    break;
            }
        }

        // Iterate over each row of bricks
        for (let r = 0; r < num_brick_rows; r++) {
            // Iterate over each column of bricks
            for (let c = 0; c < num_brick_cols; c++) {
                // Check if the current brick is defined
                const brick = bricks[r][c];
                if (brick && brick.status !== 0) {
                    // Calculate the distance from the ball's center to the brick's center
                    const distX = Math.abs(ball.x - (brick.x + brick.width / 2));
                    const distY = Math.abs(ball.y - (brick.y + brick.height / 2));

                    // Check if the ball is within the brick's bounds
                    if (distX <= (brick.width / 2 + ball.radius) && distY <= (brick.height / 2 + ball.radius)) {
                        // Determine the collision side and handle the collision
                        const deltaX = brick.width / 2 + ball.radius - distX;
                        const deltaY = brick.height / 2 + ball.radius - distY;

                        if (deltaX >= deltaY) {
                            // Top or bottom collision
                            ball.dy = -ball.dy;
                            ball.y += ball.dy;
                        } else {
                            // Left or right collision
                            ball.dx = -ball.dx;
                            ball.x += ball.dx;
                        }

                        // Perform actions after the collision
                        ballHitsBrick(brick);
                        playSound(brickHitSound);

                        //one bounce per frame
                        break;


                    }
                }
            }

            // Check if all bricks are destroyed
            if (bricks.every(row => row.every(brick => brick.status === 0))) {
                gamePaused = true;
                if (currentLevel + 1 === levelLayouts.length) {
                    // Player has won the game
                    gameWon = true;
                    deleteGameState();
                    showGameOverModal(); // Show the modal window with a winning message and score
                } else {
                    showNextLevelModal();
                }
            }
        }
    }

    /**
     * Function to handle the movement of the paddle
     */
    function paddleMovement() {
        if (paddle.controllingMedium.KeyboardControlled) {
            // Keyboard movement has priority
            if (rightPressed) {
                paddle.moveRight();
            } else if (leftPressed) {
                paddle.moveLeft();
            }
        }

        //this results in mice not having to press a button but touch users do.
        else if (paddle.controllingMedium.TouchControlled || paddle.controllingMedium.MouseControlled) {
            // Touch or mouse movement
            const paddleCenterX = paddle.x + paddle.width / 2;
            const distance = mouseX - paddleCenterX; // Reuse mouseX for touch input
            if (distance > 0) {
                paddle.moveRight(Math.min(distance, moveByAmount));
            } else if (distance < 0) {
                paddle.moveLeft(Math.min(-distance, moveByAmount));
            }

        }


    }

    /**
     * Check if the ball has touched the bottom of the canvas, end the game if yes
     */
    function ballTouchedBottomCheck() {
        // Game over condition
        if (ball.y >= currCanvasHeight - ball.radius / 2) {
            gamePaused = true;
            showGameOverModal();
        }
    }


    /**
     * Restart the game
     * @function
     * @description Restarts the game
     * @returns {void}
     */
    function restartGame() {
        console.log("Restarting game...");
        // Hide the game over modal
        hideGameOverModal();
        //refresh page
        // restart music
        music.currentTime = 0;
        newGame();
    }

    restartButton.addEventListener("click", restartGame);

    /**
     * Speed up the game over time
     */
    function speedUp() {
        //increase rate at which the game moves up to a certain rate. have it reach the max in X seconds
        if (gameSpeed < maxGameSpeed) {
            gameSpeed += maxGameSpeed / framesToReachMaxSpeed;
            gameSpeed = Math.min(gameSpeed, maxGameSpeed);
        }
    }

    /**
     * Manage the game speed based on the selected game speed
     * @param selectedGameSpeed
     */
    function handleGameSpeed(selectedGameSpeed) {
        switch (selectedGameSpeed) {
            case 'slowButton':
                selectedSpeed = gameSpeedOptions.SLOW;
                break;
            case 'mediumButton':
                selectedSpeed = gameSpeedOptions.MEDIUM;
                break;
            case 'fastButton':
                selectedSpeed = gameSpeedOptions.FAST;
                break;
        }
    }

    /**
     * event listener for the paddle speed input in the settings to change the paddle speed
     */
    paddleSpeedInput.addEventListener('change', () => {
        if (paddleSpeedInput.value < 1 || paddleSpeedInput.value > 10) {
            alert("Please enter a value between 1 and 10.");
            paddleSpeedInput.value = null;
        } else {
            moveByAmount = paddleSpeedInput.value * 1.3;
        }
    });


    /**
     * the game loop
     */
    function gameLoop() {
        // Clear the canvas
        ctx.clearRect(0, 0, currCanvasWidth, currCanvasHeight);

        ballTouchedBottomCheck();
        brickDestruction();
        speedUp();


        // Draw the game objects
        draw:
            bricks.forEach(row => row.forEach(brick => brick.draw()));
        powerUps.forEach(powerUp => powerUp.draw());
        ball.draw();
        paddle.draw();

        // Move the game objects
        move:
            paddleMovement();
        ball.move();
        powerUps.forEach(powerUp => powerUp.move());

        // Check for power-up collisions
        powerUps.forEach(powerUp => powerUp.ifPaddleHitGivePowerUp());

        if (!gamePaused)
            requestAnimationFrame(gameLoop);

    }

    //endregion


    //region SavingLoadingAndScore

    /**
     * Function to delete the game state
     */
    function deleteGameState() {
        localStorage.removeItem('gameState');
    }

    /**
     * Function to load saved game state
     */
    function loadLastSavedGameAndGoToGame() {
        const gameState = loadGameState();
        gamePaused = false;

        // Check if a saved game state was found
        if (gameState) {
            goToGameScreen();
            currentLevel = gameState.currentLevel;
            setUpLevel();
            initializeEventListeners()
        } else {
            // No saved game state found
            console.log("No saved game found.");
        }
    }

    /**
     * event listener for the loadbutton to load the last saved game
     */
    loadGameButton.addEventListener('click', loadLastSavedGameAndGoToGame);
    /**
     * event listener for the loadbutton to be disabled if there is no saved game
     */
    loadGameButton.addEventListener('load', () => {
        if (!checkSaveGameExists()) {
            loadGameButton.disabled = true;
        }
    });


    /**
     * Function to check if a saved game exists
     * @returns {boolean} - True if a saved game exists, false otherwise
     */
    function checkSaveGameExists() {
        if (localStorage.getItem('gameState') == null || currentLevel === 0) {
            return false;
        } else {
            return true;
        }

    }


    /**
     * Function to save the game state
     */
    function saveGameState() {
        const gameState = {
            currentLevel: currentLevel,
            currentScore: 0,
            selectedSpeed: selectedSpeed,
        };
        // Save the game state to local storage
        localStorage.setItem('gameState', JSON.stringify(gameState));

        // Enable the load game button
        loadGameButton.disabled = false;
    }

    /**
     * Function to load the game state
     * @returns {Object} - The game state object
     */
    function loadGameState() {
        const gameStateString = localStorage.getItem('gameState');
        if (gameStateString) {
            return JSON.parse(gameStateString);
        } else {
            return null;
        }
    }

    // endregion

    //region modalWindow

    /**
     * Function to show the next level modal
     */
    function showNextLevelModal() {

        // Check if the game screen is visible
        if (gameScreen.style.display === '') {
            return;
        }
        playSound(levelWonSound)
        nextLevelModal.style.display = 'flex';
        nextLevelButton.style.display = 'block';
        nextLevelText.innerText = "Good job!";

        nextLevelModal.style.animationName = "modalRiseUp";
        nextLevelButton.focus()

    }

    /**
     * Event listener for the next level button to go to the next level
     */
    nextLevelButton.addEventListener('click', () => {
        nextLevelModal.style.display = 'none';
        nextLevelButton.style.display = 'none';
        nextLevel();
    });

    /**
     * Function to show the game over modal,
     */
    function showGameOverModal() {

        if (gameScreen.style.display === '') {
            return;
        }

        //change the header based on if the player won or lost
        if (gameWon) {
            playSound(victorySound);
            gameOverHeader.textContent = "You Win!";
        } else {
            gameOverHeader.textContent = "Game Over";
            playSound(gameOverSound);
        }
        music.pause();
        gameOverModal.style.display = "flex";
        finalScoreSpan.textContent = currentLevel + 1;
        modalContent.style.animationName = "modalRiseUp";
    }

    /**
     * Function to hide the game over modal
     */
    function hideGameOverModal() {
        gameOverModal.style.display = "none"; // Hide the modal
        modalContent.style.animationName = ""; // Reset the animation
    }

    //endregion


    //region navigation
    let historyAPIState = {
        displayGame: false,
        displayMenu: true

    };


    window.history.replaceState(historyAPIState, null, "");


    /**
     * Function to hide the game screen
     */
    function hideGameScreen() {
        gameScreen.style.display = 'none';
        hideGameOverModal();
        nextLevelModal.style.display = 'none';
        nextLevelButton.style.display = 'none';
    }

    /**
     * Function to go to the main menu
     */
    function goToMainMenu() {

        historyAPIState = {
            displayGame: false,
            displayMenu: true
        };
        window.history.pushState(historyAPIState, null, "");

        changePageLayout();
        gamePaused = true;
        music.pause();

        // Add logic to stop the game or perform any cleanup
    }


    /**
     * event listener for the window popstate event, to render the correct screen
     * History Handler
     * @param event
     */
    window.onpopstate = function (event) {
        if (event.state) {
            historyAPIState = event.state;
        }
        changePageLayout(historyAPIState);
    };

    /**
     * function to render the correct screen based on the history state
     */
    function changePageLayout() {

        // Check the history state to determine which screen to display
        if (historyAPIState.displayGame) {

            mainMenu.style.display = 'none';
            gameScreen.style.display = 'block';
            window.location.hash = '#game';
            if (!checkSaveGameExists()) {
                loadGameButton.disabled = true;
            }
            hideGameOverModal();
            gamePaused = false;

        } else if (historyAPIState.displayMenu) {
            mainMenu.style.display = 'flex';
            hideGameScreen();
            gamePaused = true;

            if (!checkSaveGameExists()) {
                loadGameButton.disabled = true;
            }
        }
    }

    /**
     * Function to go to the game screen
     */
    function goToGameScreen() {
        historyAPIState = {
            displayGame: true,
            displayMenu: false
        };

        // Push the game screen state to the history API
        window.history.pushState(historyAPIState, null, "");

        if (!isMuted) {
            playSound(music);
        } else {
            music.pause();
        }
        changePageLayout()

    }

    /**
     * Event listener for the Return to Main Menu button to go to the main menu
     */
    menuButton.addEventListener("click", goToMainMenu);
    //endregion

    //region Resizing


    /**
     * Function to get the new canvas size
     */
    function getNewCanvasSize() {
        currCanvasWidth = canvas.width;
        currCanvasHeight = canvas.height;
    }

    /**
     * Function to resize the canvas based on the container size
     */
    function resizeCanvas() {
        const containerWidth = canvasContainer.offsetWidth;
        const containerHeight = canvasContainer.offsetHeight;

        // Calculate the desired canvas dimensions while maintaining the aspect ratio
        const aspectRatio = 720 / 240; // Replace with your desired aspect ratio
        const canvasWidth = Math.min(containerWidth, containerHeight * aspectRatio);
        const canvasHeight = Math.min(containerHeight, containerWidth / aspectRatio);

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        getNewCanvasSize();
    }



    /**
     * Function to update the paddle size based on the current canvas size
     */
    function updatePaddleSize() {
        paddle.height = currCanvasHeight / PADDLE_HEIGHT_PERCENT;
        paddle.width = currCanvasWidth / PADDLE_WIDTH_DEFAULT;
    }


    /**
     * Function to update the game speed based on the selected speed and current window width
     */
    function updateGameSpeed() {
        // Update the game and paddle speed based on the selected speed and current window width
        const newGameSpeed = selectedSpeed * (currCanvasWidth * moveSpeedMultiplier );
        // Calculate the speed ratio between the new and old game speeds
        // Update the paddle's move amount
        moveByAmount = paddleSpeed * (currCanvasWidth * moveSpeedMultiplier );
        // Update the gameSpeed variable with the new game speed
        gameSpeed = newGameSpeed;
    }

    /**
     * Function to resize the game screen based on the current window size
     */
    function resizeGameScreen() {
        if (gameScreen.style.display !== '') {
            resizeCanvas();
            updateGameSpeed();
        }
    }


    /**
     * Event listener for the window load event to resize the game screen
     */
    window.addEventListener('DOMContentLoaded', resizeGameScreen);
    /**
     * Event listener for the window resize event to resize the game screen
     */
    window.addEventListener('resize', resizeGameScreen);

    //endregion


    /**
     * initialize the canvas related event listeners
     */
    function initializeEventListeners() {

        /**
         * Event listener for the mouse movement
         */
        document.addEventListener("mousemove", e => {
            paddle.controllingMedium = {
                KeyboardControlled: false,
                TouchControlled: false,
                MouseControlled: true
            };
            mouseX = e.clientX - canvas.offsetLeft;
        });

        /**
         * Event listener movement key presses
         */
        document.addEventListener("keydown", e => {
            paddle.controllingMedium = {
                KeyboardControlled: true,
                TouchControlled: false,
                MouseControlled: false
            };

            if (e.key === "Right" || e.key === "ArrowRight") {
                rightPressed = true;
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                leftPressed = true;
            }
        });

        /**
         * Event listener for key releases
         */
        document.addEventListener("keyup", e => {
            if (e.key === "Right" || e.key === "ArrowRight") {
                rightPressed = false;
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                leftPressed = false;
            }
        });

        /**
         * Touch start event listener
         */
        document.addEventListener("touchstart", e => {
            if (e.target === canvas) {
                e.preventDefault();
            }

            paddle.controllingMedium = {
                KeyboardControlled: false,
                TouchControlled: true,
                MouseControlled: false
            };
            mouseX = e.touches[0].clientX - canvas.offsetLeft; // Use touches array for touch events
        }, {passive: false}); // Set passive option to false for non-passive listener

        /**
         * Touch movement event listener
         */
        document.addEventListener("touchmove", e => {
            if (e.target === canvas) {
                e.preventDefault();
            }

            paddle.controllingMedium = {
                KeyboardControlled: false,
                TouchControlled: true,
                MouseControlled: false
            };
            mouseX = e.touches[0].clientX - canvas.offsetLeft; // Use touches array for touch events
        }, {passive: false}); // Set passive option to false for non-passive listener

    }


</script>


</html>
